#!/usr/bin/env python
import roslib; roslib.load_manifest('Frizzle')
import rospy
import sensor_msgs.msg as sm
import cv_bridge
import cv
import numpy
import math, cmath

D = {}

########################## INITIALIZATION FUNCTIONS ##########################

def init_globals():
    """ Sets everything up """
    global D
    # Create image stuff
    cv.NamedWindow('dist')
    cv.MoveWindow('dist', 0, 0)
    D["bridge"] = cv_bridge.CvBridge()
    cv.SetMouseCallback('dist', onMouse, None)

    # Create slider stuff
    D["sliders"] = {"left_x":200, "right_x":440, "left_y":240, "right_y":240, 
                    "vertical":240}
    cv.NamedWindow('sliders')
    cv.MoveWindow('sliders', 640, 0)
#    D["slider_keys"] = ["left_x", "right_x", "vertical"]
    cv.CreateTrackbar("left_x", 'sliders', D["sliders"]["left_x"], 640, 
                      lambda x: change_slider("left_x", x) )
    cv.CreateTrackbar("right_x", 'sliders', D["sliders"]["right_x"], 640, 
                      lambda x: change_slider("right_x", x) )
    cv.CreateTrackbar("left_y", 'sliders', D["sliders"]["left_y"], 480, 
                      lambda x: change_slider("left_y", x) )
    cv.CreateTrackbar("right_y", 'sliders', D["sliders"]["right_y"], 480, 
                      lambda x: change_slider("right_y", x) )
    cv.CreateTrackbar("vertical", 'sliders', D["sliders"]["vertical"], 480, 
                      lambda x: change_slider("vertical", x) )
    
    # Points we will look at
    D["p1"] = (200, 240)
    D["p2"] = (440, 240)

    # for display purposes
    D["font"] = cv.InitFont(cv.CV_FONT_HERSHEY_SIMPLEX, 0.5, 0.5, 0, 2)


######################## END INITIALIZATION FUNCTIONS ########################

######################### IMAGE PROCESSING FUNCTIONS #########################

def show_points():
    """ draws circles on image at points p1 and p2 """
    global D

    # draw circles around the points
    cv.Circle(D["image"], D["p1"], 10, 1, thickness=1, lineType=8, shift=0)
    cv.Circle(D["image"], D["p1"], 9, 0, thickness=1, lineType=8, shift=0)
    cv.Circle(D["image"], D["p1"], 11, 0, thickness=1, lineType=8, shift=0)

    cv.Circle(D["image"], D["p2"], 10, 1, thickness=1, lineType=8, shift=0)
    cv.Circle(D["image"], D["p2"], 9, 0, thickness=1, lineType=8, shift=0)
    cv.Circle(D["image"], D["p2"], 11, 0, thickness=1, lineType=8, shift=0)

    # display angle on screen
    cv.Rectangle(D["image"], (213, 17), (426, 57), 1, cv.CV_FILLED)
    value_string = ""
    if D["angle"] == "nan":
        value_string = "Angle: NaN"
    else:
        value_string = ("Angle: %.1f" % D["angle"]) # formatted printing
    cv.PutText(D["image"], value_string, (280, 42), D["font"], 0)


def two_points():
    """ Looks at two points in the depth image and does calculations """
    global D
    deg_per_pix_x =  57.0 / 639.0

    D["p1"] = (D["sliders"]["left_x"], D["sliders"]["vertical"])
    D["p2"] = (D["sliders"]["right_x"], D["sliders"]["vertical"])

    # get depths
    d1 = D["image"][D["p1"][1], D["p1"][0]]
    d2 = D["image"][D["p2"][1], D["p2"][0]]

    if math.isnan( d1 ) or math.isnan( d2):
        D["angle"] = "nan"
        return

    # compute angle between pixels
    dy = d1 - d2

    # beta depends on if pixel_x is below or above 320
    b1 = 61.5 + D["p1"][0]*deg_per_pix_x
    if D["p1"][0] > 320:
        b1 = 180 - (61.5 + D["p1"][0]*deg_per_pix_x)
    
    b2 = 180 - (61.5 + D["p2"][0]*deg_per_pix_x)
    if D["p2"][0] < 320:
        b2 = 61.5 + D["p2"][0]*deg_per_pix_x

    x1 = d1 / (math.tan(math.radians(b1)))
    x2 = d2 / (math.tan(math.radians(b2)))
    
    # dx depends on location of pixel_x of both p1 and p2
    dx = x1 + x2
    if (D["p1"][0] < 320 and D["p2"][0] < 320) or (D["p1"][0] > 320 and D["p2"][0] > 320):
        dx = abs(x1 - x2)

    D["angle"] = math.degrees(math.atan2(dy, dx))

####################### END IMAGE PROCESSING FUNCTIONS #######################

############################# CALLBACK FUNCTIONS #############################

def handle_next_image(data):
    """ Displays the image, calls find_info """
    global D

    # get the image from the Kinect
    D["image"] = D["bridge"].imgmsg_to_cv(data, "32FC1")
    
    two_points()
    show_points()

    # handle key presses
    key_press = cv.WaitKey(5) & 255
    if key_press != 255: check_key_press( key_press )

    # display the image
    cv.ShowImage('dist', D["image"])


def onMouse(event, x, y, flags, param):
    """ the method called when the mouse is clicked """
    global D

    # if the left button was clicked
    if event==cv.CV_EVENT_LBUTTONDOWN:
        print "x, y are", x, y
        pixel_val= D["image"][y,x]
        print "the pixel's depth value is", pixel_value


def check_key_press(key_press):
    """ this method handles user key presses appropriately """
    global D

    # if a 'q' or ESC was pressed
    if key_press == 27 or key_press == ord('q'):
        print "quitting"
        rospy.signal_shutdown( "Quit requested from keyboard" )
    if key_press == ord('p'):
        two_points()

def change_slider(name, new_point):
    """ changes slider value """
    global D
    D["sliders"][name] = new_point

########################### END CALLBACK FUNCTIONS ###########################
if __name__ == "__main__":
    """ Main function, performs setup and starts program running """

    # Initialize our node
    rospy.init_node('distanceReader')

    # Initialize globals
    init_globals()

    # Subscribe to the image topic
    rospy.Subscriber('/camera/depth/image',sm.Image, handle_next_image)

    # Run until something stops us
    rospy.spin()
